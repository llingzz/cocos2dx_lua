syntax = "proto2";
package pb_common;

message data_head
{
	optional int32 protocol_code = 1;
	reserved 2 to 8;
	optional int32 data_len = 9;
	optional bytes data_str = 10;
}

enum protocol_code
{
	protocol_register = 1;
	protocol_register_response = 2;
	protocol_join_room = 3;
	protocol_join_room_response = 4;
	protocol_ready = 5;
	protocol_ready_response = 6;
	protocol_begin = 7;
	protocol_frame = 8;
	protocol_tcp_close = 9;
	protocol_leave_room = 10;
	protocol_leave_room_response = 11;
	protocol_ping = 12;
	protocol_pong = 13;
}

message data_user_register
{
	optional bytes username = 1;
	optional bytes password = 2;
}

message data_user_register_response
{
	optional int32 return_code = 1;
	optional int32 userid = 2;
}

message data_user_join_room
{
	optional int32 userid = 1;
}

message data_user_join_room_response
{
	optional int32 userid = 1;
	optional int32 roomid = 2;
}

message data_ready
{
	optional int32 userid = 1;
	optional int32 roomid = 2;
	reserved 3 to 8;
}

message data_ready_response
{
	optional int32 userid = 1;
	optional int32 roomid = 2;
	optional int32 return_code = 3;
	reserved 4 to 8;
}

message data_begin
{
	optional uint32 rand_seed = 1;
	repeated int32 userids = 2;
}

message data_ope
{
	optional int32 userid = 1;
	optional int32 frameid = 2;
	optional int32 opecode = 3;
	optional int32 ackframeid = 4;
}

message data_frame
{
	optional int32 userid = 1;
	optional int32 frameid = 2;
	optional int32 opecode = 3;
}

message data_ope_frames
{
	optional int32 frameid = 1;
	repeated data_frame frames = 2;
}

message data_frames
{
	repeated data_ope_frames frames = 1;
}

message data_tcp_close
{
	optional int32 userid = 1;
	optional int32 token = 2;
}

message data_user_leave_room
{
	optional int32 userid = 1;
	optional int32 roomid = 2;
}

message data_user_leave_room_response
{
	optional int32 userid = 1;
	optional int32 roomid = 2;
}

message data_ping
{
	optional int32 userid = 1;
	optional int32 idx = 2;
}

message data_pong
{
	optional int32 userid = 1;
	optional int32 idx = 2;
}
